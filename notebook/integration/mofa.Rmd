---
title: "Integration of scNMTseq data using MOFA and mixOmics"
author: "Al J Abadi"
params:
  on_hpc: !r Sys.info()['user'] != 'alabadi'
  on_mac: !r Sys.info()['user'] == 'alabadi'
output:
  html_document:
    toc: true
---

```{r, warning=FALSE, message=FALSE}
setup_libPaths()

library(MultiAssayExperiment)
library(MOFA)
library(mixOmics)
library(reticulate)
library(here)
library(scran)
library(ggplot2)
# Using a specific python binary

which_py <- ifelse(params$on_hpc, "/usr/local/easybuild/software/Python/2.7.13-GCC-6.2.0-bare/bin/python", "/usr/local/bin/python")
use_python(which_py, required = TRUE)
```


```{r, echo=FALSE}
knitr::opts_chunk$set(eval = TRUE, cache = FALSE)
```

# Data

## MAE

```{r}
gastru.mae <- readRDS(here('output/scnmtseq_gastrulation_mae_826-cells_orderedFeatures.rds'))  # MAE experiment
gastru.mae
```

```{r}
study_assays <- c("rna", "met_promoter", "acc_promoter", "met_p300", "acc_p300")
```

```{r}
study_mae <- gastru.mae[,,study_assays]
```

rna data has not been filterred yet.

## rna

The `rna` assay is simply the `logcounts(sce)` so no filtering so far. A closer look:

```{r}
rna <- readRDS(here("data/gastrulation/rna/parsed/SingleCellExperiment_matching-cells.rds"))
```
```{r}
rowdata <- as.data.frame(rowData(rna))
ggplot(rowdata) + geom_histogram(aes(log10_mean_counts))
```

Get UMI corrected logcounts:

```{r}
library(sctransform)
counts_vst <- vst(as(counts(rna), "dgCMatrix"),n_genes = NULL, min_cells = 10, return_cell_attr = TRUE, return_corrected_umi = TRUE)
counts_umi_crrected <- as(counts_vst$umi_corrected, "matrix")
## logcounts of UMI corrected data
logcounts_umi_corrected <- log(counts_umi_crrected+1)
saveRDS(logcounts_umi_corrected, file = here("data/gastrulation/rna/parsed/logcounts_umi_corrected_min-10-cells.rds"))
```
```{r}
plot(x = rowMeans(logcounts_umi_corrected), rowVars(logcounts_umi_corrected))
```


```{r}
sort_hvgs_logcounts <- function(log_counts = NULL, ## a matrix of normalised counts
                                min_var_quantile = NULL
                         ){ 
  
  s2 <- matrixStats::rowVars(log_counts)
  
  if (!is.null(min_var_quantile)) {
    low_var_genes <- s2 < quantile(s2, min_var_quantile)
    log_counts <- log_counts[!low_var_genes,]
    s2 <- s2[!low_var_genes]
  }
  
  
  ranks <- order(s2, decreasing = TRUE)
  out <- log_counts[ranks,]
  
  out
}
```

```{r}
rna <- sort_hvgs_logcounts(logcounts_umi_corrected, min_var_quantile = 0.05)
```

```{r, eval=params$on_mac, echo=params$on_mac}
## for subsetting the P x N data on local computer
subset_pn <- function(mat, n=50, p=100) {
  n <- min(n, dim(mat)[2])
  p <- min(p, dim(mat)[1])
  mat[seq_len(p), seq_len(n)]
}

subset_mae <- function(mae, samples=50, max_feat=150) {
  for (i in seq_along(experiments(mae))) {
    feats <- min(dim( mae[[i]])[1], max_feat)
    mae[[i]] <-  mae[[i]][seq_len(feats),]
  }
  mae[,seq_len(samples),]
}

if (params$on_mac) {
  gastru.mae <- subset_mae(gastru.mae)
}

```


```{r}
runtimes <- list()
MOFAobjects <- list()
```

```{r}
MOFAobject <- createMOFAobject(study_mae)
MOFAobject
```


## Overview of training data
```{r}
plotDataOverview(MOFAobject)
```

# Step 2: Fit the MOFA model
The next step is to fit the model. 
This part of the pipeline is implemented in Python, so first of all make sure you have the corresponding package installed (see installation instructions and read the FAQ if you have problems).

## Define options

### Define data options
The most important options the user needs to define are:  

* **scaleViews**: logical indicating whether to scale views to have unit variance. As long as the scale of the different data sets is not too high, this is not required. Default is `FALSE`.  

* **removeIncompleteSamples**: logical indicating whether to remove samples that are not profiled in all omics. The model can cope with missing assays, so this option is not required. Default is `FALSE`.  

```{r}
DataOptions <- getDefaultDataOptions()
DataOptions$scaleViews <- TRUE
DataOptions
```

### Define model options
Next, we define model options. The most important are:  

* **numFactors**: number of factors (default is 0.5 times the number of samples). By default, the model will only remove a factor if it explains exactly zero variance in the data. You can increase this threshold on minimum variance explained by setting `TrainOptions$dropFactorThreshold` to a value higher than zero.  

* **likelihoods**: likelihood for each view. Usually we recommend gaussian for continuous data, bernoulli for binary data and poisson for count data. By default, the model tries to guess it from the data.  

* **sparsity**: do you want to use sparsity? This makes the interpretation easier so it is recommended (Default is `TRUE`).  
```{r}
ModelOptions <- getDefaultModelOptions(MOFAobject)
ModelOptions$numFactors <- 4
ModelOptions
```

### Define training options
Next, we define training options. The most important are:  

* **maxiter**: maximum number of iterations. Ideally set it large enough and use the convergence criterion `TrainOptions$tolerance`.  

* **tolerance**: convergence threshold based on change in the evidence lower bound. For an exploratory run you can use a value between 1.0 and 0.1, but for a "final" model we recommend a value of 0.01.  

* **DropFactorThreshold**: hyperparameter to automatically learn the number of factors based on a minimum variance explained criteria. Factors explaining less than `DropFactorThreshold` fraction of variation in all views will be removed. For example, a value of 0.01 means that factors that explain less than 1\% of variance in all views will be discarded. By default this it zero, meaning that all factors are kept unless they explain no variance at all.  

```{r}
TrainOptions <- getDefaultTrainOptions()

# Automatically drop factors that explain less than 2% of variance in all omics
TrainOptions$DropFactorThreshold <- 0

TrainOptions$seed <- 2017

TrainOptions
```

## Prepare MOFA
`prepareMOFA` internally performs a set of sanity checks and fills the `DataOptions`, `TrainOptions` and `ModelOptions` slots of the `MOFAobject`
```{r}
MOFAobject <- prepareMOFA(
  MOFAobject, 
  DataOptions = DataOptions,
  ModelOptions = ModelOptions,
  TrainOptions = TrainOptions
)
```

Optionally, we can choose to regress out some (technical) covariates before training, using a simple linear model. For example, here we can choose to remove the effect of sex. Ideally, all undesired sources of variation should be removed a priori from the model. The reason ebing that, if strong technical factors exist, the model will "focus" on capturing the variability driven by the technical factors, and small sources of biological variability could be missed.  
(Note: uncomment and running the function below will lead to a slight modification of the results)
```{r}
# MOFAobject <- regressCovariates(
#   object = MOFAobject,
#   views = c("Drugs","Methylation","mRNA"),
#   covariates = MOFAobject@InputData$Gender
# )
```

## Run MOFA
Now we are ready to train the `MOFAobject`, which is done with the function `runMOFA`. This step can take some time (around 15 min with default parameters). For illustration we provide an existing trained `MOFAobject`.  
IMPORTANT NOTE: The software has evolved since the original publication and the results are not 100% reproducible with the last versions. Yet, the output should be very similar (if not improved) to the pre-existent model.
```{r MOFA-run, include=FALSE, echo=TRUE}
runtimes$gastru$MOFA <-  system.time({
  MOFAobject <- runMOFA(MOFAobject)
})

```

```{r}
if (params$on_hpc) {
  saveRDS2(MOFAobject, file = here("output/MOFAobject.rds"), suffix = "auto", log = paste0(study_assays, collapse = ", "))
}
```

## run DIABLO

```{r}
X <- lapply(as.list(experiments(study_mae)), t)
```

```{r}
create_keepX <- function(mae, keepX) {
  rep(list(keepX), length(mae)) %>% set_names(names(mae))
}
```


```{r}
design <- 0.5*(1-diag(length(study_mae)))
keepX <- c(5,10,20,50)
runtimes$gastru$tuno_diablo <- system.time({
  tune_diablo_res <-
    tune.block.splsda(
      X = X,
      Y = study_mae$lineage10x_2,
      ncomp = 2,
      test.keepX = create_keepX(study_mae, keepX = keepX),
      design = design,
      cpus = parallel::detectCores()
    )
})

```

```{r}
if (params$on_hpc) {
  saveRDS2(tune_diablo_res, file = here("output/tune_diablo_res.rds"), suffix = "auto", log = paste0(study_assays, collapse = ", "))
}
```

```{r}
table(runtimes$gastru)
```


# SessionInfo
```{r}
sessionInfo()
```

```{r, eval=FALSE}
knitr::purl("mofa.Rmd")
```

