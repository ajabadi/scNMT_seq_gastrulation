---
title: "imputation"
output: html_document
params:
  times: 3 ## number of times to repeat NA introduction
  on_mac: !r Sys.info()['user'] == 'alabadi'
  on_hpc: !r Sys.info()['user'] != 'alabadi'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TO DO

* shall we drop outliers in norm calculations? #TODO1
* we should do it multiple times, scale the columns each time and count and throw away outliers 
  which are defined e.g. as the ones 0.9*SD away (or better to use MAD) and calculate the norm.
  The criteria should include both the Frobenious norm and the number of outliers. #TODO2
  _Obviously, imputation by the mean will not create any outliers_.

```{r}
library(here)
library(parallel)
library(mixOmics)
library(knitr)
library(magrittr)
```

```{r}
## ------------------------------------------------------------------------ ##
## add random NA entries at 'prop' proportion
rand_na <- function(mat=matrix(1:100, ncol = 20), prop=0.3){
  ## calculate the total number of NAs
  total_na <- floor(prop*prod(dim(mat)))
  vec <- as.vector(mat)
  vec[sample(seq_along(vec), size = total_na, replace = FALSE)] <- NA
  matrix(vec, ncol = ncol(mat), dimnames = dimnames(mat))
}

## ------------------------------------------------------------------------ ##
## calculate the norm b/w matrices x and y
calc_norm <- function(xorigin=NULL, ximpute=NULL, type="F", center_scale=TRUE, normalise = TRUE) {
  
    if (normalise) {
    number_of_NAs <- sum(ximpute != xorigin, na.rm = TRUE)
    if (number_of_NAs == 0) stop("metrices are identical - did you impute?")
    if (number_of_NAs == prod(dim(xorigin))) stop("all NAs?")
    }
  
  if (isTRUE(center_scale)) {
    ximpute <- scale(ximpute)
    xorigin <- scale(xorigin)
  }
  diff <- xorigin-ximpute
  diff[is.na(diff)] <- 0
  out <- norm(diff, type="F") #TODO 1

  if (normalise) {
    out <- out/sqrt(number_of_NAs)
  }
  return(out)
}

## ------------------------------------------------------------------------ ##
## impute NAs as mean of columns
impute_by_means <- function(x) {
  apply(x, 2, function(y){
  y[is.na(y)] <- mean(y, na.rm=TRUE)
  y
})
}
```

## NIPALS vs mean

```{r}
#' Calculate norm of matrices resulting from subtracting the original from
#' imputed matrix
#'
#' @param data_matrix  a data mtrix
#' @param comps components for NIPALS
#' @param norm_method method passed to 'norm'
#' @param prop_na proportion of missing values to add

#' @examples
library(parallel)
benchmark_nipals_against_mean <- function(data_matrix, comps=ncol(data_matrix), norm_method="F", prop_na=0.3, times=3) {
  formals(mclapply)$mc.cores <- detectCores()
  comps <- min(comps, ncol(data_matrix))
  data_matrix_na <- lapply(seq_len(times), function(null) rand_na(data_matrix, prop = prop_na))
  ## -------- mean
  data_matrix_mean <- lapply(data_matrix_na, impute_by_means)
  fnorm_mean <- mclapply(data_matrix_mean, function(x) calc_norm(xorigin = data_matrix, ximpute = x))
  ## -------- nipals
  data_matrix_nipals <- mclapply(data_matrix_na, function(x) nipals(x, ncomp = comps, reconst = TRUE)$rec)
  
  retrieve_non_missings <- function(post_impute, pre_impute) {
    ## function te retrieve the original non-missing values into the imputed matrix
    post_impute[!is.na(pre_impute)] <-  pre_impute[!is.na(pre_impute)]
    return(post_impute)
  }
  
  data_matrix_nipals <- mapply(FUN = function(x, y) 
    retrieve_non_missings(post_impute = x, pre_impute = y), x = data_matrix_nipals, y = data_matrix_na, SIMPLIFY = FALSE)
  
  fnorm_nipals <- mclapply(data_matrix_nipals, function(x) calc_norm(xorigin = data_matrix, ximpute = x))
  
  fnorm_mean <- Reduce(mean, fnorm_mean)
  fnorm_nipals <- Reduce(mean, fnorm_nipals)
  
  return(data.frame(fnorm_nipals = fnorm_nipals,
              fnorm_mean = fnorm_mean )) 
}
```

```{r, echo=FALSE, message=FALSE}
library(mixOmics)
data("breast.TCGA")
data("liver.toxicity")
data("srbct")
data("multidrug")
data("nutrimouse")
```

```{r}
# X <- breast.TCGA$data.train$mirna
# X <- as.matrix(X)
# benchmark_nipals_against_mean(data_matrix = X, prop_na = 0.1, comps = 3, times = params$times)
```

Create a heatmap of how nipals performs compared to means for list of datasets and `NA` prportions:

```{r}
benchmark_data <- function(data_list, na_props, comps = 10, subset=0, times=2) {
  ## if subset required
  if (isTRUE(subset > 0)) {
    data_list <- lapply(data_list, function(x){
      dim2 <- min(subset, dim(x)[2])
      x[,seq_len(dim2)]
    })
    
  }
  df_nipals <- df_means <- data.frame(matrix(nrow = length(data_list), ncol = length(na_props), dimnames = list(names(data_list), paste0("NA_prop_", na_props))))
  
  for (i in seq_along(data_list)) {
    for (j in seq_along(na_props)) {
      data_set <- as.matrix(data_list[[i]])
      na_prop <- na_props[j]
      out <- benchmark_nipals_against_mean(data_matrix = data_set, prop_na = na_prop, comps = comps, times = times)
      df_nipals[i, j] <- out$fnorm_nipals
      df_means[i, j] <- out$fnorm_mean
    }
  }
  diff_norms <- df_nipals - df_means
  res <- list(norms_nipals = df_nipals, norms_means = df_means, norms_diff = diff_norms)
  return(res)
}
```

```{r}
data_list <- list(breast.TCGA = breast.TCGA$data.train$mirna, liver.toxicity = liver.toxicity$gene, multidrug = multidrug$ABC.trans, srbct = srbct$gene, nutrimouse = nutrimouse$gene)
na_props <- c(0.1, 0.25, 0.4)
```


```{r}
bm_res <- benchmark_data(data_list, na_props, comps = ifelse(params$on_mac, 3L, 10L), subset = ifelse(params$on_mac, 30L, 0L), times = params$times)
```
```{r}
saveRDS2(bm_res, file= here("output/imputation_benchmark.rds"), suffix = "auto", log = paste0(paste0(names(params), ": "), paste0(params), collapse = " ; "))
```
```{r}
# bm_res <- readRDS(here("output/imputation_benchmark.rds"))
```



```{r}
#' Create a heatmap of (differences of) norms for NIPALS  and mean imputation methods
#'
#' @param norm_df a data.frame of type:
#'                NA_prop_0.1 NA_prop_0.25 NA_prop_0.4
#' breast.TCGA    -0.20806496   -0.2100575  -0.1668734
#' liver.toxicity -0.21905374   -0.2133410  -0.2138071
#' @param colors low cond high colors
#' @param legend_title legend title
#' @param y y axis title
#' @param title figure title
#' @param diff is it a diff of norms or norms?
#'
#' @return
#' @export
#'
#' @examples
diff_tile <- function(norm_df, colors = c("green", "red"), legend_title = "norm(nipals-mean)\n(standardised)", y = "Proportion of NAs in data", title = "NIPALS vs mean imputation", diff = TRUE) {
  diff_df <- reshape2::melt(t(norm_df)) %>% set_colnames(c("NA_prop", "dataset", "norm"))
  lim <- max(abs(diff_df$norm), na.rm = TRUE)*1.01
  lims <- if (diff) c(-lim,lim) else c(0, lim)
  ggplot(diff_df, aes(x = dataset, y = NA_prop, fill = norm)) + geom_tile() + scale_fill_gradientn(colors = colors, limits=lims) + guides(fill = guide_legend(title = legend_title)) + labs(y = y, title = title)
}
```

```{r}
diff_tile(bm_res$norms_diff)
# diff_tile(bm_res$norms_means)
# diff_tile(bm_res$norms_nipals)
```




